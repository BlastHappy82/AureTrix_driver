# AureTrix Keyboard Driver

## Overview
AureTrix is a web-based configuration tool for hall effect keyboards compatible with the SparkLink SDK. It provides a professional, browser-based interface for customizing keyboard behavior without requiring native drivers. Key capabilities include multi-layer key remapping, macro creation, comprehensive RGB lighting control, advanced hall effect features (Dynamic Keystroke, Magnetic Point Triggering, Rapid Trigger), sensor calibration, profile management, a real-time debugging interface, and a custom layout creator with controller emulation metadata support. The application runs entirely in the browser using the WebHID API, aiming to be the leading configuration solution for SparkLink-compatible hall effect keyboards.

## User Preferences
Preferred communication style: Simple, everyday language.

## System Architecture
### Frontend Architecture
The application is built with Vue.js 3, using the Composition API and TypeScript. It follows a component-based Single Page Application (SPA) architecture with Vue Router for lazy-loaded routes and Pinia for state management with persistence. SCSS handles styling. Key design patterns include composables for reusable logic and a layout system for dynamic rendering of various physical keyboard layouts using absolute pixel positioning. A batch processing pattern is implemented to prevent hardware overload by batching SDK calls during extensive updates.

### Data Flow Architecture
User interactions trigger `KeyboardService` methods, which encapsulate SparkLink SDK calls. The SDK communicates with the keyboard via WebHID. Responses update Pinia stores, leading to reactive UI updates. Connection status, device identification, macro library, and travel profiles are persisted via localStorage.

### Service Layer
-   **KeyboardService.ts:** Abstraction layer for hardware interaction, managing device discovery, WebHID pairing, auto-reconnection, SparkLink SDK API wrappers, and connection lifecycle.
-   **ExportService.ts:** Handles complete profile backup and restore functionality, orchestrating data collection, assembling `KeyboardConfig` objects, and managing export/import operations via the SDK.
-   **DebugKeyboardService.ts:** A dedicated service for development and testing, offering SDK access without interfering with the main application state.
-   **LayoutStorageService.ts:** Manages custom keyboard layouts using IndexedDB for persistent storage, handles JSON export/import for backups, and generates GitHub issue submission links for community contributions.

### Key Technical Decisions
1.  **WebHID over Native Drivers:** Chosen for cross-platform compatibility, no installation, and browser security.
2.  **Batch Processing for SDK Calls:** Crucial for managing hardware communication efficiency when sending numerous updates.
3.  **Service Separation Pattern:** Separates `KeyboardService`, `ExportService`, `LayoutStorageService`, and `DebugKeyboardService` for clear separation of concerns.
4.  **Layout Configuration System:** Centralized management of absolute positioning data for accurate rendering of diverse keyboard layouts. Uses a 3-tier priority system for layout loading: (1) **IndexedDB** - User-created custom layouts stored locally via LayoutStorageService checked first by productName, allowing personal customizations to override all other layouts, (2) **sharedLayout.ts** - Community-contributed layouts with precise measurements checked second by productName (e.g., Slice75 HE), serving as high-quality defaults, and (3) **layoutMap** - Standard layouts by keyCount (61, 67, 68, 80, 82, 84, 87 key) as final fallback. This prioritization ensures user customizations take top priority, community layouts provide better defaults than generic layouts, and the system gracefully falls back when no specific layout exists. Layout loading uses an in-memory cache (`customLayoutsCache`) loaded from IndexedDB on app startup via `loadCustomLayouts()` in main.ts. When users save custom layouts in the Layout Creator, `refreshCustomLayouts()` is called to reload the cache, ensuring changes are immediately available app-wide without requiring a page refresh. The Layout Creator includes Share button verification that automatically disables GitHub issue submission when a community layout already exists for a keyboard's productName, preventing duplicate submissions while still allowing users to save custom modifications locally to IndexedDB.
5.  **Standardized Measurement System:** All layout measurements use the industry-standard mechanical keyboard sizing where 1u = 19.05mm. The mmToPx conversion ratio (3.7795275591) is centralized in `keyUnits.ts` and imported consistently across all files (MappedKeyboard.ts, layoutConfigs.ts, LayoutCreator.vue) to prevent rendering inconsistencies. Row spacing follows the formula: (vertical_gap || 0) + 19.05mm + 1mm, where the default is 20.05mm. All predefined layouts in layoutMap use standard key sizes from keyUnits.ts for consistency.
6.  **Type Safety with TypeScript:** Ensures type consistency across the application, especially between physical keys and remapped values in SDK calls and UI.
7.  **SDK Reconnection Error Suppression:** Addresses the SDK's internal auto-reconnection behavior that logs NotAllowedError when devices reconnect. For normal reconnections, error suppression is activated in `handleDisconnect` before the SDK attempts reconnection, then cleared in `handleConnect` after `autoConnect()` succeeds. A 10-second silent timeout ensures cleanup happens even if reconnection fails. For managed operations (polling rate changes, factory resets), error suppression is activated when the operation starts and remains active through the entire disconnect/reconnect cycle. `handleDisconnect` always updates connection state but only sets up reconnection handling when not in a managed operation. `handleConnect` activates a 2-second post-reconnection suppression window immediately upon connect, before calling `autoConnect()`, allowing the suppression timer to run in parallel with initialization. To handle the SDK's timing race condition where reconnection errors log slightly after our code completes, console.error restoration is delayed using `errorSuppressionCleanupTimeout`. The delayed cleanup callback checks if any operations are still active before restoring, preventing suppression leaks when new operations start during the delay window. This prevents console pollution while maintaining proper error logging for other operations. The `isPostReconnectionSuppression` flag is exposed through the connection store to enable UI visibility of the suppression state. After polling rate changes, `handlePollingRateChange()` in App.vue implements an optimized state-based page reload mechanism that polls both `connectionStore.isInitialized` and `!connectionStore.isPostReconnectionSuppression` every 200ms (max 15s timeout), reloading immediately when both conditions are met. Because the 2-second suppression timer runs in parallel with initialization (which typically takes 1-3 seconds), the page can reload as soon as the longer of the two processes completes, reducing typical reload time to 2-4 seconds while preventing race conditions where the page would reload while cleanup timers are still active.
8.  **SDK Initialization System:** Implements a comprehensive initialization flow to ensure the SparkLink SDK is fully ready before making API calls. The SDK requires an internal handshake after `keyboard.init()` completes, during which the ORDER_TYPE_ROES channel (used for polling rate and system mode queries) is not yet responsive. To address this, the system uses an explicit readiness gate: after connection, `waitForSDKReady()` polls ORDER_TYPE_ROES with exponential backoff (200ms base + 100ms per attempt, up to 10 attempts) until it responds successfully, confirming the SDK is fully initialized. The `initializeKeyboard()` method orchestrates the complete sequence: wait for SDK ready → sync hardware settings sequentially → mark initialized. A mutex (`initializationPromise`) prevents concurrent initialization calls that would cause ORDER_TYPE_ROES contention. Auto-retry logic attempts initialization up to 3 times (initial + 2 retries) with 1s/2s delays, checking device connection before each retry. Connection store tracks initialization state (`isInitializing`, `isInitialized`, `initializationError`) which gates UI controls and provides user feedback. On disconnect, `handleDisconnect()` clears the initialization promise and resets state via `clearInitialization()`. This eliminates the unreliable behavior where polling rate retrieval required 3-5 manual refreshes by ensuring the SDK is deterministically ready before making API calls.
9.  **Complete Configuration Snapshot:** Export collects the full keyboard state by querying all keys using batch processing, reconstructing the macro library, and using `getApi()` for system settings lacking dedicated getters.
10. **Custom Layout Creator:** A full-page visual layout builder (`/layout-creator`) matching the Performance/RapidTrigger page pattern for UI cohesion. Features a title header, centered large virtual keyboard grid using `.key-grid` styling, and bottom settings panel positioned below the keyboard. Users specify row counts and row gaps (with 0.1mm step granularity) displayed as horizontal rows (Row0-Row5 on top, Gap0-Gap5 on bottom, vertically aligned) to generate a virtual keyboard, then click keys to edit sizes and per-key gaps. Multi-select support allows clicking multiple keys to toggle selection, then applying size/gap changes to all selected keys simultaneously, with a "Clear Selection" button for easy deselection. Key sizing features dual input modes: (1) Size (Preset) dropdown for quick selection of standard sizes dynamically sourced from keyUnits.ts (1u=19.05mm, 1.25u=23.8125mm, 1.5u=27.5mm, 1.75u=32.3mm, 2u=35.999mm, 2.25u=42.8625mm, 2.75u=51.2mm, 6.25u=119.38mm), and (2) Size (mm) number input with 0.1mm step for precise fine-tuning beyond presets. Selecting a preset updates the mm field; typing directly in mm allows custom values independent of presets. VirtualKey interface stores both `size` (units for UI state) and `sizeMm` (actual mm value as source of truth for calculations and exports). Gap inputs use 0.1mm step for fine control. Eliminates the need for column gaps by using gap-after values on individual keys. Includes automatic controller emulation metadata detection via `getAxisList()` SDK call. Layouts are stored locally in IndexedDB and can be exported in four formats: (1) Save Layout to IndexedDB, (2) Export JSON for backup/restore, (3) Export Compact Code in `communityLayout.ts` syntax using `Array.fill()` and `.concat()` chains (e.g., `Array(13).fill(19.05)`), wrapped in productName key, and (4) Share button that opens a GitHub issue with pre-filled compact layout code for community contributions. The compact export automatically optimizes consecutive identical values, generates `Array(n).fill({})` for empty gap arrays, and wraps output in `"ProductName": { ... }` format ready to paste into `communityLayout.ts`. All exports use actual mm values from `sizeMm` field. Row spacing calculation uses formula: `rowSpacing = (vertical_gap || 0) + uToMm(1) + 1` where uToMm(1) dynamically pulls the standard 1u key height from keyUnits.ts and the additional 1mm provides built-in visual spacing between rows. All vertical and horizontal positioning calculations use uToMm(1) for standard key height, ensuring consistency with keyUnits.ts definitions and automatic updates if standard sizes change. GitHub repository URL configured as https://github.com/BlastHappy82/AureTrix_driver for layout sharing.

## External Dependencies

### Hardware Integration
-   **SparkLink SDK (@sparklinkplayjoy/sdk-keyboard v1.0.14):** Official SDK for communication with hall effect keyboards, enabling key remapping, macro management, travel distance configuration, sensor calibration, RGB lighting control, and advanced features.
-   **WebHID API (Browser Native):** Browser API for USB HID device communication, requiring Chromium-based browsers and HTTPS.

### Build Tools & Development
-   **Vite (v7.1.6):** Build tool and dev server.
-   **TypeScript (v5.9.2):** Provides type safety and IDE support.

### Runtime Dependencies
-   **Vue 3 (v3.5.21):** Reactive UI framework.
-   **Vue Router (v4.5.1):** Client-side routing with lazy loading.
-   **Pinia (v3.0.3):** State management.
-   **pinia-plugin-persistedstate (v4.5.0):** Enables localStorage persistence for Pinia stores.

### Testing
-   **Vitest (v3.2.4):** Vite-native unit test runner.
-   **@vue/test-utils (v2.4.6):** Utilities for Vue component testing.

### Package Management
-   **pnpm (v10.17.0):** Fast, disk-efficient package manager.